---
template: post
title: 파이썬이 피클링할 수 없는 객체 - 1
subtitle: date: 2019-11-03T12:00:00Z
thumb_img_path: "/images/python-logo-inkscape.svg"
content_img_path: ''
excerpt: 파이썬 pickle 모듈이 직렬화/역직렬화할 수 없는 객체와 그 이유에 대해서 알아봅니다.

---

# 파이썬 피클링할 수 없는 객체 - 1
파이썬에는 pickle이라는 객체를 직렬화/역직렬화 하기 위한 모듈이 있습니다. 파이썬에서 모든 것은 객체이기 때문에 거의 모든 것을 직렬화/역직렬화가 가능한 모듈이지요. 그래서 이 모듈은 다양한 용도로  사용됩니다.  대표적으로 파이썬에 내장 어있는 multiprocessing 모듈은 프로세스 간에 파이썬 객체를 주고받기 위해서 pickle을 사용합니다. 

 pickle은 유용한 모듈이지만,  몇가지 한계가 있습니다.

1. 직렬화 모듈 중에서 퍼포먼스가 빠른 편은 아닙니다.
2. 보안 리스크. 언 피클 시, 임의의 코드를 실행하는 공격이 가능합니다. 외부 통신에는 사용할 수 없습니다.
3. pickle이 모든 파이썬 객체를 직렬화할 수 있는 것은 아닙니다. 

이 포스트에서 다룰 것은 3번에 대해서입니다.  파이썬 공식 문서에 따르면, 피클링할 수 있는 객체는 다음 같습니다.

* None, True, False
* 정수, 실수, 복소수
* 문자열, 바이트열, 바이트 배열
* 피클 가능한 객체만 포함하는 tuple, list, dict, set
* 모듈 최상위 수준에서 정의된 함수 (lambda가 아니라 def 를 사용하는)
* 모듈 최상위 수준에서 정의된 내장 함수
* 모듈 최상위 수준에서 정의된 클래스
* 그런 클래스의 인스턴스 중에서 \_\_dict\_\_나 \_\_getstate\_\_()를 호출한 결과가 피클 가능한 것

 그러면 대부분의 객체는 피클링 할 수 있는 것 아닐까요? 맞습니다. 일반적으로  대부분의 객체는 피클링 할 수 있습니다. 위 리스트에서 문제가 될 만한 것은 람다 함수나 “모듈 최상위 수준에서 정의되지 않은” 함수와 클래스입니다.

이런 객체들이 피클링 되지 않는 이유는 피클이 객체를  \_\_qualname\_\_(qualified name)을 통해서 찾기 때문입니다.  qualified name은 global scope에서 해당 객체가 위치하는 path를 나타냅니다.  

```python
class A:
	pass
print(A.__qualname__)
# A

def b(d):
	def c():
		return d
	return c

print(b().__qualname__)
# b.<locals>.c

e = lambda x: x
print(e.__qualname__)
#<lambda>
```

 A는 모듈 최상위 수준에 선언된 클래스이므로  생성 시점에 현재 scope와 클래스의 이름 사용해서 path를 알 수 있습니다. 현재 스코프는 global scope이고,  클래스 명이 A이므로 path는 A입니다.

반면, c는 b 함수가 호출될 때 생기는 Local Scope에 정의가 되는 함수입니다. 따라서 path는 b.<locals>.c 입니다. 이 path는 b 함수를 호출 했을 때만 의미가 있는 <locals>가 포함되어 있기 때문에 b 함수를 호출하기 전에는 c 함수에 대해서 알 수 없습니다. 그마저도 b를 호출할 때 인자에 따라서 함수 자체가 달라질 수 있기 때문에 이 path로는 함수를 재생성할 수 없지요. 

 e와 같은 람다도 마찬가지입니다. lambda는 익명 함수이기 때문에 선언 시점에는 함수명을 알 수 없습니다. 그래서 path는 <lambda> 뿐이지요. 이 람다 함수가 어떤 이름의 변수에 대입될  지 선언 시점에는 알 수 없으니까요.

그래서, lambda나 모듈 최상위 수준에서 정의되지 않은 함수는 피클링되거나 언피클링 될 수 없습니다. 해당 객체의 qualified name을 알더라도 객체의 구체적인 구현을 알 수 없기 때문입니다.

하지만 이런 제약사항을 우회할 수 있는 방법이 있습니다. 예를 들어 데코레이터로 씌워진 함수들은 원래 함수가 local scope의 함수로 대체되는데도 피클링과 언피클링이 가능합니다. 어떻게 이 것이 가능한지는 다음 포스트에서 다루도록 하겠습니다.
